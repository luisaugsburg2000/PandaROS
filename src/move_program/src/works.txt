#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <cmath>
#include <memory>
#include <thread>

#include <moveit/move_group_interface/move_group_interface.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
#include <tf2/LinearMath/Quaternion.h>

// Joint callback function
void jointCallback(
  rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr sawyer_pub,
  sensor_msgs::msg::JointState &joint_message,
  double &elapsed_time,
  double frequency,
  double amplitude,
  double step)
{
  double target_position = amplitude * sin(2 * M_PI * frequency * elapsed_time);
  double target_velocity = amplitude * 2 * M_PI * frequency * cos(2 * M_PI * frequency * elapsed_time);

  for (double &pos : joint_message.position) {
    pos = target_position;
  }
  for (double &vel : joint_message.velocity) {
    vel = target_velocity;
  }

  // Publish the joint message
  sawyer_pub->publish(joint_message);

  // Update elapsed time
  elapsed_time += step / 1000.0;
}

void executeMoveGroup(
  rclcpp::Node::SharedPtr node,
  const rclcpp::Logger &logger)
{
  moveit::planning_interface::MoveGroupInterface MoveGroupInterface(node, "panda_arm");

  // Define target pose
  tf2::Quaternion tf2_quat;
  tf2_quat.setRPY(0, 0, -3.14 / 2);
  geometry_msgs::msg::Quaternion msg_quat = tf2::toMsg(tf2_quat);

  geometry_msgs::msg::Pose GoalPose;
  GoalPose.orientation = msg_quat;
  GoalPose.position.x = 0.3;
  GoalPose.position.y = -0.3;
  GoalPose.position.z = 0.4;

  // Set target pose and plan
  MoveGroupInterface.setPoseTarget(GoalPose);

  moveit::planning_interface::MoveGroupInterface::Plan plan1;
  auto const outcome = static_cast<bool>(MoveGroupInterface.plan(plan1));

  if (outcome)
  {
    RCLCPP_INFO(logger, "Plan successful. Executing...");
    MoveGroupInterface.execute(plan1);
    RCLCPP_INFO(logger, "Execution finished.");
  }
  else
  {
    RCLCPP_ERROR(logger, "Planning failed!");
  }
}

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);

  auto node = rclcpp::Node::make_shared("sawyer_robot");

  // Initialize publisher
  auto sawyer_pub = node->create_publisher<sensor_msgs::msg::JointState>("joint_command", 10);

  // Initialize joint message
  sensor_msgs::msg::JointState joint_message;
  joint_message.name = {"panda_joint1"};
  joint_message.position = {0.0};
  joint_message.velocity = {0.0};

  // Control variables
  double frequency = 0.1;
  double amplitude = 1;
  double elapsed_time = 0.0;
  double step = 20; // milliseconds

  // Create timer
  auto timer = node->create_wall_timer(
    std::chrono::milliseconds(static_cast<int>(step)),
    [&]() {
      jointCallback(sawyer_pub, joint_message, elapsed_time, frequency, amplitude, step);
    }
  );

  // Run MoveIt! in a separate thread
  std::thread moveit_thread(executeMoveGroup, node, rclcpp::get_logger("move_program"));

  // Spin the node for timer callbacks
  rclcpp::spin(node);

  // Wait for MoveIt! thread to finish
  if (moveit_thread.joinable())
  {
    moveit_thread.join();
  }

  rclcpp::shutdown();
  return 0;
}